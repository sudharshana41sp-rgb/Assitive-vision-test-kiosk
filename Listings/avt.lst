C51 COMPILER V9.56.0.0   AVT                                                               09/27/2025 20:19:19 PAGE 1   


C51 COMPILER V9.56.0.0, COMPILATION OF MODULE AVT
OBJECT MODULE PLACED IN .\Objects\avt.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE avt.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listings\avt.l
                    -st) TABS(2) OBJECT(.\Objects\avt.obj)

line level    source

   1          #include <reg51.h>
   2          #include <string.h> 
   3          
   4          // --- LCD Control Pin Definitions (P3) ---
   5          sbit rs = P3^2; // Register Select
   6          sbit en = P3^3; // Enable
   7          // LCD Data Bus is P2 (Standard 8-bit mode)
   8          
   9          // --- Keypad I/O Pin Definitions (P1) ---
  10          // Rows (Output) are P1.0 - P1.3
  11          sbit r1 = P1^0;
  12          sbit r2 = P1^1;
  13          sbit r3 = P1^2;
  14          sbit r4 = P1^3;
  15          // Columns (Input) are P1.4 - P1.6
  16          sbit c1 = P1^4;
  17          sbit c2 = P1^5;
  18          sbit c3 = P1^6;
  19          
  20          // --- Function Prototypes ---
  21          void delay();
  22          void cmd (int);
  23          void data1 (char);
  24          void lcd_init(); // Renamed from lcd() for clarity
  25          void display(char *s);
  26          int key();
  27          void disp(int);
  28          void uart_init();
  29          void uart_tx(char);
  30          void uart_tx_string(char *s); // New function
  31          
  32          int k; // Global variable to store the key value
  33          
  34          // ====================================================================
  35          // --- UTILITY FUNCTIONS ---
  36          // ====================================================================
  37          
  38          void delay() {
  39   1          int i,j;
  40   1          // Delay loop (approx. 1ms at 12MHz, though precise timing is less critical here)
  41   1          for(i=0;i<10;i++) 
  42   1              for(j=0;j<1200;j++);
  43   1      }
  44          
  45          // ====================================================================
  46          // --- LCD DRIVER FUNCTIONS (8-bit Mode, P2 Data) ---
  47          // ====================================================================
  48          
  49          void cmd(int a) {
  50   1          P2 = a; // Send command byte to P2
  51   1          rs = 0; // Command Mode
  52   1          en = 1;
  53   1          delay();
  54   1          en = 0;
C51 COMPILER V9.56.0.0   AVT                                                               09/27/2025 20:19:19 PAGE 2   

  55   1      }
  56          
  57          void data1(char j) {
  58   1          P2 = j; // Send data byte to P2
  59   1          rs = 1; // Data Mode
  60   1          en = 1;
  61   1          delay();
  62   1          en = 0;
  63   1      }
  64          
  65          void lcd_init() {
  66   1          delay(); // Initial power-on delay
  67   1          cmd(0x38); // 8-bit mode, 2 lines, 5x7 font
  68   1          cmd(0x0C); // Display ON, Cursor OFF, Blink OFF (Original was 0x0E: Cursor ON)
  69   1          cmd(0x01); // Clear Display
  70   1          cmd(0x06); // Entry Mode Set (Increment cursor)
  71   1          cmd(0x80); // Set cursor to start of line 1
  72   1      }
  73          
  74          void display(char *s){
  75   1          while(*s!='\0'){
  76   2              data1(*s);
  77   2              s++;
  78   2          }
  79   1      }
  80          
  81          // ====================================================================
  82          // --- UART FUNCTIONS ---
  83          // ====================================================================
  84          
  85          void uart_init() {
  86   1          // TMOD: Timer 1, Mode 2 (8-bit auto-reload)
  87   1          TMOD = 0x20; 
  88   1          // TH1: 0xFD for 9600 Baud @ 11.0592MHz crystal
  89   1          TH1 = 0xFD; 
  90   1          // SCON: Mode 1 (8-bit UART), REN=0 (Transmit only)
  91   1          SCON = 0x50; 
  92   1          // TR1: Start Timer 1
  93   1          TR1 = 1; 
  94   1      }
  95          
  96          void uart_tx(char c) {
  97   1          SBUF = c;
  98   1          while(TI == 0); // Wait for transmission to complete
  99   1          TI = 0;         // Clear the flag for the next byte
 100   1      }
 101          
 102          void uart_tx_string(char *s) {
 103   1          while (*s != '\0') {
 104   2              uart_tx(*s);
 105   2              s++;
 106   2          }
 107   1      }
 108          
 109          // ====================================================================
 110          // --- KEYPAD SCAN FUNCTION ---
 111          // Maps key presses to integers: 1-9, 0, 10 (*), 11 (#)
 112          // ====================================================================
 113          
 114          int key() {
 115   1          int x = 12; // Default: No key pressed (return value 12)
 116   1      
C51 COMPILER V9.56.0.0   AVT                                                               09/27/2025 20:19:19 PAGE 3   

 117   1          // Row 1 (r1=0)
 118   1          P1 = 0xFF; // Set all P1 HIGH
 119   1          r1 = 0;
 120   1          if(c1==0){ x=1; while(c1==0); return x; } // Key '1'
 121   1          if(c2==0){ x=2; while(c2==0); return x; } // Key '2'
 122   1          if(c3==0){ x=3; while(c3==0); return x; } // Key '3'
 123   1      
 124   1          // Row 2 (r2=0)
 125   1          P1 = 0xFF; 
 126   1          r2 = 0;
 127   1          if(c1==0){ x=4; while(c1==0); return x; } // Key '4'
 128   1          if(c2==0){ x=5; while(c2==0); return x; } // Key '5'
 129   1          if(c3==0){ x=6; while(c3==0); return x; } // Key '6'
 130   1      
 131   1          // Row 3 (r3=0)
 132   1          P1 = 0xFF; 
 133   1          r3 = 0;
 134   1          if(c1==0){ x=7; while(c1==0); return x; } // Key '7'
 135   1          if(c2==0){ x=8; while(c2==0); return x; } // Key '8'
 136   1          if(c3==0){ x=9; while(c3==0); return x; } // Key '9'
 137   1      
 138   1          // Row 4 (r4=0)
 139   1          P1 = 0xFF; 
 140   1          r4 = 0;
 141   1          if(c1==0){ x=10; while(c1==0); return x; } // Key '*'
 142   1          if(c2==0){ x=0;  while(c2==0); return x; } // Key '0'
 143   1          if(c3==0){ x=11; while(c3==0); return x; } // Key '#'
 144   1      
 145   1          return x; // Returns 12 if no key is pressed
 146   1      }
 147          
 148          // ====================================================================
 149          // --- KEY ACTION/DISPLAY FUNCTION ---
 150          // ====================================================================
 151          
 152          void disp(int x) {
 153   1          cmd(0x01); // Clear screen
 154   1          cmd(0x80); // Line 1
 155   1          
 156   1          switch(x){
 157   2              case 1: 
 158   2                  display("CATARACT TEST");
 159   2                  cmd(0xC0); display("Loading...");
 160   2                  uart_tx_string("CMD:CATARACT\n");
 161   2                  break;
 162   2              case 2: 
 163   2                  display("GLARE TEST");
 164   2                  cmd(0xC0); display("Loading...");
 165   2                  uart_tx_string("CMD:GLARE\n");
 166   2                  break;
 167   2              case 3: 
 168   2                  display("LOW CONTRAST");
 169   2                  cmd(0xC0); display("Loading...");
 170   2                  uart_tx_string("CMD:LOWCONTRAST\n");
 171   2                  break;
 172   2              case 10: // Key '*'
 173   2                  display("MENU SELECTED");
 174   2                  cmd(0xC0); display("Press 1, 2, or 3");
 175   2                  uart_tx_string("CMD:MENU\n");
 176   2                  break;
 177   2              case 11: // Key '#' - Used as Exit/Back
 178   2                  display("EXIT/RESTART");
C51 COMPILER V9.56.0.0   AVT                                                               09/27/2025 20:19:19 PAGE 4   

 179   2                  cmd(0xC0); display("KIOSK WELCOMES");
 180   2                  uart_tx_string("CMD:RESTART\n");
 181   2                  break;
 182   2              default:
 183   2                  display("Input: "); // Default feedback for 0, 4-9
 184   2                  // Convert integer to ASCII char before display/transmission
 185   2                  data1(x + '0'); 
 186   2                  cmd(0xC0); 
 187   2                  display("Error/Debug key.");
 188   2                  // Send the raw key value for debugging
 189   2                  uart_tx_string("DBG:");
 190   2                  uart_tx(x + '0');
 191   2                  uart_tx('\n');
 192   2          }
 193   1      }
 194          
 195          // ====================================================================
 196          // --- MAIN PROGRAM ---
 197          // ====================================================================
 198          
 199          void main() {
 200   1          
 201   1          lcd_init();
 202   1          uart_init();
 203   1      
 204   1          display("KIOSK WELCOMES");
 205   1          cmd(0xC0);
 206   1          display("TEST YOUR EYE");
 207   1      
 208   1          while(1){
 209   2              int new_key = 12; // 12 means no key pressed
 210   2              
 211   2              // ?? BLOCKING LOOP: Waits for a key press (new_key != 12) ??
 212   2              do {
 213   3                  new_key = key(); 
 214   3              } while(new_key == 12); 
 215   2              
 216   2              // Key found! Execute the action once.
 217   2              disp(new_key);
 218   2          }
 219   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    549    ----
   CONSTANT SIZE    =    217    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      2       4
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
